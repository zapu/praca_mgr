\chapter{Prototype}
\label{ch:prototype}

This chapter will describe implementation of the prototype, and reason about used technologies.

Prototype was created to test if virtual machine technologies are suitable for use in computing platform. HTTP is leveraged as a communication protocol between nodes and the market. BitTorrent protocol is used to distribute said virtual machines to client. Nodes run VirtualBox virtualization software.

Hypothetical network using system described in this thesis is shown in diagram~\ref{f:protomain}. All nodes connect to the server using HTTP, and communicate with one another using BitTorrent protocol.

\begin{figure}
\centering
\includegraphics{diagrams/PrototypeMain.pdf}
\caption{Prototype diagram}
\label{f:protomain}
\end{figure}

The prototype implements both client software and the market software, as well as one testing project.

\section{Functional specification}

\subsection{Server}

Server is ran by market operator. Server tasks are as follows:
\begin{enumerate}
	\item \label{ps:register} let nodes register themselves,
	\item \label{ps:hand} hand out jobs,
	\item \label{ps:collect} collect results,
	\item \label{ps:measure} measure trust,
	\item \label{ps:track} keep track of project progress.
\end{enumerate}

Task~\ref{ps:register} refers to ability of server to register new nodes and authenticate already registered ones. Node authentication is done with public-key cryptography. Worker uses public/private key pair to to authenticate its request to the server. When connecting for the first time, a permanent record is left in the server's database which is used to recognize that particular client from then on.

"Hand out jobs" task (\ref{ps:hand}) means that server should keep a database of jobs and be able to distribute them to nodes. System presented by this thesis works in a way that the nodes ask for jobs, and the server searches database for suitable job, based on node's trust.

Server should be able to collect results (\ref{ps:collect}) and keep them in a database. By being able to match results with one another and thus confirming them, server is measuring trust (\ref{ps:measure}) of nodes. Those two altogether give the server an ability to decide whether a job is considered finished or not, so the server is able to measure progress (\ref{ps:track}) of the project.

\subsection{Client}

Client is software running on worker computers. Client should be able to:
\begin{enumerate}
	\item \label{cs:auth} authenticate itself to the server,
	\item \label{cs:recv} receive job from the server,
	\item \label{cs:compute} compute received work,
	\item \label{cs:send} send back results of the computation.
\end{enumerate}

(\ref{cs:auth}) means that the client should be able to present itself to the server so both the client can ensure it communicates with entity it think it does, and the server can ensure the client is who it says it is. Methods of doing so are described in section~\ref{s:authentication}.

Receiving jobs from the server (\ref{cs:recv}) consists of two tasks. First is receiving the project, which is the virtual machine and its metadata, from the server. Project files are distributed  After installing and setting the virtual machine up, the client will then ask for job files. Job files are distributed using HTTP.

When the virtual machine is ready and powered up, job files are sent to the machine and it can start the computation (\ref{cs:compute}). When results are ready, virtual machine sends the results to the client, which then sends them back to the server (\ref{cs:send}).

This process is then repeated. The client asks for next job after finishing one. When there are no jobs left, the client will ask for next project.

The process is also shown in the figure~\ref{f:clientflow}.

\begin{figure}
\centering
\includegraphics{diagrams/ClientFlowchart.pdf}
\caption{Client flowchart}
\label{f:clientflow}
\end{figure}

\section{Authentication}
\label{s:authentication}

Authentication is a two step process. Firstly, the server has to gain trust of the client. The server can do it by either presenting a certificate signed by Certificate Authority, or presenting a self-signed certificate, but transferring the certificate in secure and trusted manner beforehand. For this prototype, we will be working with self-signed certificates, but using the CA is also an implemented option.

Secondly, the server is configured in a way that it will request certificates from the clients. Each client has to generate a public/private key pair and use the private key to authenticate itself when connecting to the server. The certificate fingerprint is used to identify clients. Each client will have different, generated by themselves, key pair, therefore different certificate fingerprint, and due to that, the server is able to identify clients unambiguously using their certificate fingerprints alone.

\section{Architecture and implementation of the server}

\subsection{Server objects}

This section describes how the server keeps data about projects, jobs, and results, internally. Methods of storing this data in permanent storage is described in section~\ref{s:database}.

\subsection{Client API Module}
\label{s:cliapi}

This module provides a way for clients to communicate with the server. The communication happens over HTTPS, with use of authentication described in section~\ref{s:authentication}.

Client API exposes the following methods that can be remotely called by clients:

\subsubsection*{fetchProject}

\emph{fetchProject} API method is used by clients to discover on what project there will be working on. Result of that call is project id, that will be used internally to fetch project data (via another call, which returns project \emph{.torrent} file, described in~\ref{s:project_download_module}).

This call will result in assigning client to a project when the client is not already in a project. Otherwise, current project id is returned, and no changes are made to the client. So this call is not only used to request the project, but also to discover what project is the client working on, after it starts.

Method of scheduling projects is described in section~\ref{s:scheduler}.

\subsubsection*{fetchJob}

\emph{fetchJob} method is used to discover what job client will be working on. Result of this call is job id, which is used later to fetch job data, and to send results back (with \emph{sendResult} method).

This call results in finding new work for client only when client has finished previous job (or hasn't fetched a job in their project yet). There is no way of changing job or aborting one. When client already has a job and calls \emph{fetchJob}, job id of current job is returned, and no changes are made to the client. \emph{fetchJob} is used when client starts (along with \emph{fetchProject}) to start working, whether it will result in getting new project and/or new job, or continuing where the client has left.

Methods of scheduling jobs are described in section~\ref{s:scheduler}.

\subsubsection*{sendResult}

\emph{sendResult} is called by client when their computation is finished and results are ready to be sent back. Results are sent as a binary data and the server does not care about the format. This is done to ensure maximum flexibility as far as projects are concerned. After receiving, initial correctness of the is computed, which is the reliability of the node. 

Hash of the data (using SHA1) is computed. We can now easily compare newly received result to results that have been handed in before. For each of the results that are equal (hash values match), \emph{total score} is increased. Job record keep \emph{total score} for each unique result received, by mapping it to the hash value. When unique result's score exceeds $1$, the job is marked as \emph{done}.

If there is are no prior results with hash matching, the raw data is also saved to the database.

Example of completing results is shown in figure~\ref{f:sendresultsex}.

After sending the result, client should ask for another job, using \emph{fetchJob} method.

\begin{figure}
\centering
\includegraphics{diagrams/SendResultsExample.pdf}
\caption{Two examples of job with two results. Job in example on the left is marked as \emph{done}, because sum of correctness of results exceeds $1$. Example on the right shows undone job, because even though correctness exceeds $1$, the nodes has not agreed on the results (the hash differs).}
\label{f:sendresultsex}
\end{figure}

\subsection{Task scheduler module}
\label{s:scheduler}

This module is responsible for assigning workers to projects and distributing jobs among workers within a project.

\subsubsection{Assigning to projects}

Managing multiple projects and scheduling them efficiently was not one of the goals of the prototype, so assigning workers to project is very simple. The project distributor chooses the first project that satisfies the constraint, that the project has undone jobs.

\subsubsection{Distributing jobs}

Prototype has an implementation of algorithm of distributing jobs described in section~\ref{s:jobdist}.

\subsection{Project download module}
\label{s:project_download_module}

\begin{comment}
https://github.com/superafroman/node-torrent
\end{comment}

\emph{Project download} module is responsible for distributing project files (virtual machines and their metadata). The module exposes only one function, that takes project metadata and returns a \emph{.torrent} file to return to client. This module also starts its own BitTorrent tracker and serves initial, seed, download. BitTorrent supports peer to peer downloading from multiple peers, so a new client will fetch project data not only from the server, but also from other clients who already downloaded or are also downloading.

This module uses both \emph{node-torrent} and \emph{node-torrent-tracker}. \emph{Node-torrent} is used as a BitTorrent client, it allows the server act as a peer in the peer to peer network. This way the server can be the initial peer from which workers download project files.

\emph{Node-torrent-tracker} is used to coordinate peer discovery, if Distributed Hash Table~\cite{loewenstern2008dht} fails.

\subsection{Database}
\label{s:database}

\section{Architecture and implementation of the client}

Client is built from the following separated modules:

\begin{enumerate}
\item \emph{Market module}, used to communicate with the market.
\item \emph{Download module}, used to fetch project data from the market.
\item \emph{Virtual machine module}, used to manage virtual machines.
\item \emph{Work module}, used to communicate with project software running on a virtual machine.
\end{enumerate}

\subsection{Market module}

\begin{comment}
http://nodejs.org/api/https.html
http://nodejs.org/api/tls.html
\end{comment}

Market module provides a way for client to communicate with server software over secure channel. It uses HTTPS, which is a HTTP over TLS/SSL, and is provided by Node.js. The module exposes the following functionality:

\subsubsection*{createMarket}

Is used to create a Market object which is then used to do all the client-market communication. The following options have to be set
\begin{itemize}
\item hostname: A domain name or IP address of the server.
\item port: Port the client should connect to.
\item key: Private key of the client.
\item cert: Certificate to use. Can be self signed.
\end{itemize}

Market class methods will then establish secure HTTPS connection when executing any of the following methods. Private key and certificate are presented to the server in a way that the client will be authenticated, so the server knows exactly which client is making the request.

\subsubsection*{Market.fetchProject}

Used to fetch the project (either new, or the one the client has already been working on) metadata from the server. Refer to section~\ref{s:cliapi} for more information.

\subsubsection*{Market.fetchJob}

Used to fetch job data along with its metadata. Refer to section~\ref{s:cliapi} for more information.

\subsubsection*{Market.sendResult}

Used to send back job results. Refer to section~\ref{s:cliapi} for more information.

\subsection{Download module}

\begin{comment}
https://github.com/zapu/node-torrent
https://github.com/superafroman/node-torrent

https://www.virtualbox.org/
\end{comment}

Download module uses \emph{node-torrent} module to provide ability to use BitTorrent protocol to fetch project data. Project data consists of VirtualBox virtual machine files. The module export one function, which given the \emph{.torrent} file, will proceed with the download and call back when it is completed.

The \emph{.torrent} contains all the metadata necessary to download and verify data, which in our case is virtual machine image. Also included are URL addresses of torrent trackers, which serve as a "meeting point" for nodes, in case node discovery via Distributed Hash Table fails.

Figure~\ref{f:clientprojdownload}~shows how all three modules (\emph{Market API}, \emph{Download module}, and \emph{Virtual machine module}) are used to fetch virtual machine with project data from Market. First an API call is made to acquire \emph{.torrent} file. Then, \emph{Download module} is used to connect to peers and fetch torrent data to local file system. The \emph{virtual machine module} then registers the downloaded virtual machine. This action makes it ready to use.

\begin{figure}
\centering
\includegraphics{diagrams/ClientProjectDownload.pdf}
\caption{Sequence diagram showing how virtual machine is fetched from Market and then registered within Virtual machine module (described in section~\ref{s:c_vm_mod}).}
\label{f:clientprojdownload}
\end{figure}

\subsection{Virtual machine module}

\label{s:c_vm_mod}

\begin{comment}
http://www.virtualbox.org/manual/ch08.html
\end{comment}

Virtual machine module is used to launch the project virtual machine using VirtualBox virtualizer. Internally, it uses \emph{VBoxManage}\footnote{VBoxManage is an utility provided by Virtual Box. \url{http://www.virtualbox.org/manual/ch08.html}} for operating on Virtual Box. \emph{VBoxManage} provides functionality, such as

\begin{itemize}
\item \emph{import} - to import virtual machine file,
\item \emph{unregistervm} - to remove already added virtual machine,
\item \emph{controlvm} - to power off or reset virtual machine,
\item \emph{startvm} - to start virtual machine.
\end{itemize}

\subsection{Work module}

Work module is used to communicate with project executable running within virtual machine. It works by creating a HTTP server in local network (network between the virtual machine and the host operating system). The project then makes requests to this web server, receiving work items, until there is no more work left. Sequence diagram in figure~\ref{f:clientseq} shows an example situation where work is fetched from the market (\emph{MarketAPI}), a virtual machine is powered on (via \emph{VM Module}) and data is exchanged with computing program on the virtual machine using \emph{work module} (\emph{Virtual machine project} on the diagram).

\begin{figure}
\centering
\includegraphics{diagrams/ClientSequence.pdf}
\caption{Sequence diagram showing interaction between client, Market module, Virtual machine module and Work module.}
\label{f:clientseq}
\end{figure}

The protocol is based on HTTP and uses simple GET and POST methods. First, the guest OS is able to ask for job data when it's done setting itself up, using GET request. Then, after computation finishes, it does a POST request to send job computation results. It is important to note that the communication is one-sided as far as data exchange is considered - guest OS initiates both transferring job data and transferring job results. The protocol, however, describes one action in which the host OS initiates communication. It is the "PING" mechanism, which is used to check whether guest OS machine is still computing, and has not crashed because of any critical unforeseen failure. 

The "PING" mechanism is implemented using HEAD requests. Guest OS is expected to host a HTTP server responding to HEAD requests if computing is being performed without problems. Host OS will periodically perform the requests. If any times out, that means the application is not performing computation at the time and has probably hung. Guest OS is to be restarted when such behavior is detected. Guest OS has to ensure that it will not reply to this request when computation is interrupted.
